<!DOCTYPE html>
<p>WASM in Console</p>
<script>

const memory = new WebAssembly.Memory({initial: 1});
const importsObject = {
    env: {
        memory,
        malloc() {

        },
        socket(/* int, int, int */) {
            console.log('socket')
            return 0;
        },
        htons(/* int */) {
            console.log('htons')
            return 0;
        },
        bind(/* int socket, const struct sockaddr *address, socklen_t address_len */) {
            console.log('bind')
            return 0;
        },
        listen(/* int, int */) {
            console.log('listen')
            return 0;
        },
        accept(/* int, struct sockaddr *, socklen_t * */) {
            console.log('accept')
            return 1;
        },
        read(/* int fd, void *buf, int count */) {
            console.log('read')
            return 0;
        },
        printf(a, b/* const char *, ... */) {
            return 0;
        },
        send(/* int, const void *, int, int */) {
            console.log('send')
            return 0;
        },
        strlen(/* const char * */) {
            console.log('strlen')
            return 0;
        },
        /* void * */ memset (a, /* void * ptr, int value, size_t num */) {
            console.log('memset')
            return 0;
        },
        /* int */ puts (/* const char * str */) {
            console.log('puts')
            return 0;
        },
    },
}

// Set the stack size
//
// If you run out of memory, this is probably too small.
// This means 10k bytes of stack space.
//
// You can check the main.wat file to see it loads this as the initial stack offset.
new Uint32Array(memory.buffer)[1] = 10000

WebAssembly.instantiateStreaming(fetch('main.wasm'), importsObject)
.then(obj => {
    obj.instance.exports.main();
})
</script>
